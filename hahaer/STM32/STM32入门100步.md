共27.5个小时的视频课程，2倍速的话，共14个小时，一天看2小时的教学视频，7天学完。

目前看到了第3步；100/7=15，一天学15步。
step 7:
![[Pasted image 20250130013634.png]]
- step 49 2025/2/5
I2C总线的上拉电阻，上拉在SDA、SCL上，阻值为1~10K，具体需要测试才能确定最优阻值，确定优劣的方法为测量通信速率高的时候的通信质量
![[Pasted image 20250206003149.png]]
- step 59 RS232通信连接，只有下图才可以实现通信
![[Pasted image 20250206180219.png]]
- step67 为什么ADC只有2个，却可以每个采集好几路数据？这难道不相当于好几个ADC吗？
STM32F103C 系列的 ADC 只有两个独立的 ADC 模块（ADC1 和 ADC2），但每个 ADC 都可以采集多个模拟通道的数据。这是因为 STM32F103C 的 ADC 采用 **多路复用（Multiplexing）** 机制。

### 1. **多路复用原理**

STM32F103C 的 ADC 模块内部有一个**模拟开关**（Multiplexer，简称 MUX），它可以依次选择不同的模拟输入通道，将选定的通道连接到 ADC 采样电路。这样，即使只有 2 个 ADC 模块，每个 ADC 仍然可以在不同时间点轮流采样多个输入通道。

### 2. **多通道采集的方式**

STM32F103C 的 ADC 支持多通道扫描模式（Scan Mode），主要有以下几种工作方式：

- **单次转换模式（Single Conversion Mode）**：ADC 只转换一次选定的通道。
- **连续转换模式（Continuous Conversion Mode）**：ADC 会持续转换选定通道，一次转换完成后立即开始下一次。
- **扫描模式（Scan Mode）**：ADC 会按照设定的顺序依次转换多个通道，适用于多路数据采集。
- **定时触发模式（Trigger Mode）**：可以使用定时器或外部信号来触发 ADC 采样，适用于定期采集数据。

### 3. **等效多个 ADC**

虽然 STM32F103C 只有 2 个 ADC 模块，但由于 **多路复用 + 扫描模式**，它可以一次性采集多个模拟通道的数据。尽管这些数据是**依次**转换的（并不是同时采样），但如果转换速度足够快，就可以近似认为多个通道的数据是**同步**的。

### 4. **双 ADC 模式**

如果需要更快的采集速度，STM32F103C 还支持 **ADC1 和 ADC2 协同工作**，比如：

- **双 ADC 交替模式**：两个 ADC 交替采样，提高采样速率。
- **双 ADC 同步模式**：两个 ADC 同时采样不同的通道，适用于同步测量。

### 5. **总结**

STM32F103C 的 2 个 ADC 模块可以采集多个通道的数据，是通过 **模拟多路复用（MUX）+ 扫描模式** 实现的。虽然每次只能采样一个通道，但快速切换多个通道后，整体上就像是有多个 ADC 同时采样一样。

- step 95
为什么STM32编程时，全都是全局变量、全局函数啥的，而不会考虑限定下作用域与生存周期呢？

saying 1：
代码量不大的单片机其实没必要折腾那套[软件工程方法](https://zhida.zhihu.com/search?content_id=256339261&content_type=Answer&match_order=1&q=%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%96%B9%E6%B3%95&zhida_source=entity)。
任何教材告诉你的好习惯，好方法，其实在有必要的时候是可以舍弃的
saying 2：
根本原因在于单片机的程序设计与PC上面的程序设计的硬件资源不一样。

单片机的程序逻辑设计中会频繁地处理各类型中断，比如定时器终端、外部中断、UART中断等等。这些中断由特定的事件激活，之后会根据向量表自动运行对应的函数，而不能进行参数传递，因此必须使用全局变量来完成中断任务中对于数据的处理。

很多人的回答都是基于PC上面程序设计的流程思路分析的。在PC上利用C语言编程，函数大都都是由其他函数调用的，因此可以使用参数传递来降低全局变量的使用。
saying3：
看到一些只会写几个跑马灯程序就上来大放厥词指点江山的实在忍不住了。一个两个对着简单的几行的代码分析来分析去然后就得出不该用全局变量，幼稚得跟幼儿园两三岁的小朋友一样。你们见过几个大型的工业控制软件?什么程序简单，单片机简单，内存小，甚至还有人归结为工程师的编程习惯不好，水平不高，看着真是幼稚可笑。大型的工业控制实时系统代码量、数据量一样非常惊人，上百万行代码级别，变量能到上万个。内存奢侈到不做定点，直接用[单精度浮点](https://zhida.zhihu.com/search?content_id=262005775&content_type=Answer&match_order=1&q=%E5%8D%95%E7%B2%BE%E5%BA%A6%E6%B5%AE%E7%82%B9&zhida_source=entity)甚至双精度浮点，使用多核芯片、多个单片机进行分布式计算，但仍然**大量使用全局变量**。全局变量是工业控制程序的一个很独特的风格，这是由工业控制程序的特点所致。用于工业控制的实时系统有一个巨大的特点**:主线上能够修改数据的函数其执行顺序、周期是可以预知的，甚至内存都不需要动态分配。**可以把整个程序想象成一条流水线，数据就是这条流水线上的产品，每个函数就是流水线上的一个工位，**每一个全局变量只会被唯一一个函数修改**。产品按照一定的周期、顺序在工位上流转。工位对这些产品进行加工，加工完送到下一个工位。当然，也可能发到多个工位，**但下游的工位一定不会先于上游运行。这意味着很多工位需要同一个工位的数据时，这个工位在一个时间片内只需要执行一次。这就很好的保证了同步和效率。**负责信号采集的模块就好比给生产线提供原料的工位，独立于“生产线“采集数据，定时将采集的数据放上生产线。而负责执行的模块也是特殊的工位，独立于生产线，一直按照一定的周期读取线上的数据，并根据这些数据执行终端动作。很显然这种情况下全局变量是非常好用的，它不需要解耦，**因为处于“生产线“上的函数执行次序、周期都是可以预知的，修改它的函数也是唯一确定的，而独立于“生产线“上的模块是一个观察者，不影响“生产线“上的函数运行次序，也不会修改数据。你可以很明确的跟踪到数据当前所在的位置。而且也只有使用全局变量，才能够方便数据的跟踪。模块的维护也没有任何问题，增加、减少功能远比想象中简单。**

变量命名、模块的测试、功能安全等等等等都有相应的标准来保障。至于水平，很多这种工控系统都跟成千上万的人命打交道，过着刀头舔血的日子，决人生死于一瞬之间，能比[内存泄漏](https://zhida.zhihu.com/search?content_id=262005775&content_type=Answer&match_order=1&q=%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F&zhida_source=entity)了只需要重启个手机电脑的软件低到哪里去?

**对于交互式的非实时系统，函数的执行次序是不可预知的，修改全局变量的函数不是唯一的，所有函数共享全局变量会导致维护、调试非常困难，再加上经常需要动态分配内存，程序运行数据安全无法保障。因此对于交互式非实时系统良好的封装才会非常必要。**

多做点项目再上来放屁吧求求你们了。不考虑实际应用场景生搬硬套软件工程，只能说这种人不过是两脚书橱罢了。

saying 3
看了很多回答，我觉得很多人并没有实际做过嵌入式软件。

题目问得也比较有问题，太引战了。这个大多数就很让人费解：你是统计了多少嵌入式项目的代码得出这个结论的？

我说下我的理解。

嵌入式系统大多数情况要和底层硬件直接交互，所以他的代码会暴露出来，你就看到了很多全局变量——你看看windows的底层支持代码，不也到处全局变量吗？

硬件的抽象一定是全局变量：本质上不就是个不可变的地址吗。光这些硬件的名字，就得多少变量了？全是全局的！

底层和也要和中断打交道的。你给中断传个参啊——做不到的，没这个能力好吧！

再举个例子：翻翻FreeRTOS的源代码，看看中间有多少全局变量——工程实践上，就得这么干。

然而，你有没有发现，我说的全是接近硬件层？实时操作系统也算接近硬件层。

当你跑到应用层，就要分情况了。

你一个人一天做完的代码，那特么得简单到什么程度？这只要实现功能就好了，还讲什么工程思想？点个灯要个屁的思想——管你全局还是局部，反正错不了。

但是，如果软件系统比较复杂，至少有个像模像样的软件需求书出来了，还有个架构师——对的，嵌入式软件也有架构师的——那么，肯定就有接口了，哪个接口用全局变量的？

不过，写C的多数情况下确实有很多情况要关注内存大小的，比如：人家告诉你了，你这个线程就给了4K的栈，恰恰好，你要用个8K的缓存，你怎么可能搞个局部变量呢？

来吧，全局走起，为了不污染名字空间，撑死加个static隔离一下完事儿——动态内存？不行啊，这要紧的玩意儿，内存分配失败可就挂逼了啊……

所以，题目就是引战的，回答也都入套了，要么这帮嵌入式的水平不行，要么在那里解释不行啊，必须用全局啊……

写什么代码的人群里面还没个水平高下啊？都得Diss一下？

这全局的就水平差了？用局部的就水平高啦？以这个作为检验水平高低的标准？

写全局的，明明就是一部分硬件需求，一部分硬件限制，一部分项目小——这么做可以啊，没问题吧，有什么好骂的？稳定可靠不是第一目标吗？

你软件工程追求的这不就是这个目标吗？

问这个问题的哥们，可能都没想到引发了乱战吧？

我上面写的只可以回答你为啥要用全局变量，但是你问得大多数都用全局变量——恕我直言，我的经验里面，看过很多优秀的嵌入式软件，没有这个印象。

--- 
## 可重入函数
## 1.概述

先要澄清概念，[可重入函数](https://zhida.zhihu.com/search?content_id=241731883&content_type=Article&match_order=1&q=%E5%8F%AF%E9%87%8D%E5%85%A5%E5%87%BD%E6%95%B0&zhida_source=entity)是如何定义的。那什么是可重入函数？

这里需要特别注意，「**可重入的概念是在单线程操作系统环境下提出的。**]

如果一个函数A可以「**在任意时刻被中断然后操作系统再执行另一段代码，而这一段代码又调用了之前被中断的函数A，并且不会出错**」，则称函数A是可重入的。

可重入强调的是单一线程执行的环境下，中断之后的调用[信号处理](https://zhida.zhihu.com/search?content_id=241731883&content_type=Article&match_order=1&q=%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86&zhida_source=entity)函数， 在信号处理函数中再次进入之前被中断的函数时是安全的，执行的结果是符合预期的。所以，可重入也被称为「**异步信号安全**」，这里的异步指的是信号中断可以在任意时刻发生。

## 2.需要满足的条件

如果一个函数是可重入的，则它需要满足下述的条件。

- 函数内不能有任何的[静态变量](https://zhida.zhihu.com/search?content_id=241731883&content_type=Article&match_order=1&q=%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F&zhida_source=entity)。
- 函数内不能有任何的[全局变量](https://zhida.zhihu.com/search?content_id=241731883&content_type=Article&match_order=1&q=%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F&zhida_source=entity)。
- 函数内不能出现锁，有锁操作的函数，必然是不可重入的。
- 函数内只能有[栈变量](https://zhida.zhihu.com/search?content_id=241731883&content_type=Article&match_order=1&q=%E6%A0%88%E5%8F%98%E9%87%8F&zhida_source=entity)。
- 调用的函数也必须是可重入的。

上述条件，要求可重入函数使用的所有变量，都在当前的函数栈帧上，这样单个线程重新进入该函数时，是在新的函数栈帧上执行，与前一次该函数执行时使用的函数栈帧是隔离的，不会互相覆盖。

## 3.和线程安全的区别

可重入和[线程安全](https://zhida.zhihu.com/search?content_id=241731883&content_type=Article&match_order=2&q=%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8&zhida_source=entity)的这两个概念都涉及了函数处理资源的方式，但是，他们有这重大区别。

- 可重入概念会影响函数的外部接口，而线程安全只关心函数的实现

- 在绝大部分情况下，要将不可重入函数改为可重入的，需要修改函数接口，使得所有的数据都通过函数的调用者提供。
- 而要将非线程安全的函数改为线程安全的，则只需要修改函数的实现部分。一般通过加入[同步机制](https://zhida.zhihu.com/search?content_id=241731883&content_type=Article&match_order=1&q=%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6&zhida_source=entity)来保护共享的资源，使之不会被几个线程同时访问。

- 操作系统背景和CPU[调度策略](https://zhida.zhihu.com/search?content_id=241731883&content_type=Article&match_order=1&q=%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5&zhida_source=entity)

- 可重入是在单线程操作系统背景下，重入的函数或者子程序，按照后进先出的[线性序](https://zhida.zhihu.com/search?content_id=241731883&content_type=Article&match_order=1&q=%E7%BA%BF%E6%80%A7%E5%BA%8F&zhida_source=entity)依次执行完毕。
- [多线程](https://zhida.zhihu.com/search?content_id=241731883&content_type=Article&match_order=1&q=%E5%A4%9A%E7%BA%BF%E7%A8%8B&zhida_source=entity)执行的函数或子程序，各个线程的执行时机是由操作系统调度，不可预期的，但是该函数的每个执行线程都会不时的获得CPU的[时间片](https://zhida.zhihu.com/search?content_id=241731883&content_type=Article&match_order=1&q=%E6%97%B6%E9%97%B4%E7%89%87&zhida_source=entity)，不断向前推进执行进度。

- 可重入函数未必是线程安全的

- 例如，一个函数打开某个文件并读入数据。这个函数是可重入的，因为它的多个实例同时执行不会造成冲突；但它不是线程安全的，因为在它读入文件时可能有别的线程正在修改该文件，为了线程安全必须对文件加“[同步锁](https://zhida.zhihu.com/search?content_id=241731883&content_type=Article&match_order=1&q=%E5%90%8C%E6%AD%A5%E9%94%81&zhida_source=entity)”。

- 线程安全函数未必是可重入的

- 例如，C++11函数内静态变量的初始化是线程安全的，因为编译在初始化过程中自动加了锁，所以它是线程安全的，但是却不可重入。如果函数A内的静态变量初始时，先锁住了锁，但是释放锁之前，调用被信号中断了，在中断处理函数中，又重入了函数A（重新调用了函数A），此时会导致死锁。

![](https://picx.zhimg.com/v2-85031fe728cd126df6a2225fe02f8759_1440w.jpg)
 
---

 
STM32和FPGA可以替换吗？

STM32 和 FPGA 各有优劣，适用于不同的应用场景。以下是它们的主要区别：


## **1. 基本概念**

|**对比项**|**STM32（微控制器 MCU）**|**FPGA（现场可编程门阵列）**|
|---|---|---|
|**本质**|**基于处理器的 MCU**（一般是 ARM Cortex-M）|**硬件可编程逻辑**，可自定义数字电路|
|**工作方式**|**串行执行**（逐条执行指令）|**并行执行**（多个逻辑单元同时工作）|
|**开发语言**|C/C++|Verilog/VHDL|
|**可变性**|固定指令集，功能有限|逻辑单元可重新配置，功能自由度高|
|**适用范围**|控制类、低功耗、通用计算|高速数据处理、并行计算、专用硬件|

---

## **2. 处理能力**

|**对比项**|**STM32**|**FPGA**|
|---|---|---|
|**计算能力**|低到中（主频一般 48MHz~400MHz）|高（取决于逻辑单元，可达 GHz 级别）|
|**并行处理**|❌ 串行处理|✅ 多任务并行|
|**浮点运算**|低端无 FPU，高端 STM32H7 及以上支持 FPU|需要自行设计浮点运算单元|

📌 **结论**：

- **STM32 适用于控制任务**（如电机控制、传感器读取）。
- **FPGA 适用于高并发计算任务**（如视频处理、AI 加速）。

---

## **3. 资源 & 生态**

|**对比项**|**STM32**|**FPGA**|
|---|---|---|
|**存储**|内置 Flash（64KB ~ 2MB），RAM（16KB ~ 1MB）|需要外接 RAM，内部 BRAM 很小（通常 KB 级）|
|**外设支持**|内置 UART、SPI、I2C、ADC、DAC、PWM|需要用 HDL 自己设计这些外设|
|**开发生态**|**丰富**（CubeMX + Keil / GCC / IAR）|依赖 FPGA 厂商工具（Vivado、Quartus）|
|**功耗**|低功耗（mW 级）|高功耗（W 级）|

📌 **结论**：

- **STM32 适合单片机级应用**，开发方便，外设丰富。
- **FPGA 需要更多外围芯片**，开发门槛高，但灵活度大。

---

## **4. 典型应用**

|**应用场景**|**STM32（MCU）**|**FPGA**|
|---|---|---|
|**电机控制**|✅ PWM + ADC 直接控制|🚫 需要自己设计 PWM 逻辑|
|**物联网**|✅ 低功耗、无线通信|🚫 高功耗，不适合|
|**信号处理（FFT、滤波）**|❌ 计算速度慢|✅ 并行计算快|
|**AI 加速**|❌ 运行 AI 速度慢|✅ 高速 AI 加速（如 DNN）|
|**视频处理**|❌ 处理能力有限|✅ 高速视频流处理（HDMI/4K）|

📌 **结论**：

- **STM32 适用于一般控制类任务**，如物联网、低功耗设备、电机控制。
- **FPGA 适用于数据流计算任务**，如 AI、信号处理、高清视频处理。

---

## **5. 开发难度**

| **对比项**  | **STM32**      | **FPGA**       |
| -------- | -------------- | -------------- |
| **开发语言** | C / C++        | Verilog / VHDL |
| **编程方式** | 指令执行           | 逻辑设计           |
| **调试**   | 通过 GDB、串口、JTAG | 需要逻辑分析仪、信号探测   |
| **入门难度** | 低（适合嵌入式开发者）    | 高（需要硬件设计能力）    |

📌 **结论**：

- STM32 开发 **更容易上手**，C 语言友好。
- FPGA 开发 **更复杂**，需要掌握 **硬件描述语言（HDL）** 和 **逻辑电路设计**。

---

## **6. 价格对比**

|**对比项**|**STM32（MCU）**|**FPGA**|
|---|---|---|
|**低端价格**|$1 ~ $5|$10 ~ $50|
|**中端价格**|$5 ~ $15|$50 ~ $200|
|**高端价格**|$20 ~ $50|$100 ~ 上千|

📌 **结论**：

- STM32 **价格低廉**，适合 **成本敏感** 的产品。
- FPGA **价格较高**，适合 **高性能应用**。

---

## **7. 什么时候选 STM32？什么时候选 FPGA？**

✅ **选 STM32**：

- 低功耗、低成本应用（如传感器、无线通信、智能家居）。
- 任务是 **基于外设的控制**（如电机、LED、工业控制）。
- 计算任务不复杂，C 语言编程即可完成。

✅ **选 FPGA**：

- 需要 **高性能并行计算**（如 AI、DSP、视频处理）。
- 需要 **高速接口**（如 PCIe、DDR3/4、千兆以太网）。
- 硬件可重配置，需要**灵活定义逻辑电路**。

---

## **总结**

|**对比项**|**STM32**|**FPGA**|
|---|---|---|
|**处理能力**|串行处理，适合一般控制|并行处理，适合高性能计算|
|**开发语言**|C / C++|Verilog / VHDL|
|**功耗**|低功耗（mW 级）|高功耗（W 级）|
|**外设**|内置 UART、SPI、PWM、ADC|需要自己设计外设|
|**开发难度**|低（嵌入式开发友好）|高（需要硬件知识）|
|**成本**|低（$1-$50）|高（$10-$1000）|

### **📌 总结推荐**

- **STM32** 适合 **控制类任务**，如物联网、电机控制、嵌入式系统。
- **FPGA** 适合 **高性能计算任务**，如 AI 加速、视频处理、并行计算。

- step 96
PWM功能一般不改变输出波形的频率，只改变输出波形的占空比；
定时器输出比较器时，则既可以改变输出波形的频率，也改变其占空比；
stm32 vs 51单片机的区别？
STM32 和 8051（或 80C51）单片机是两种不同类型的微控制器，它们在性能、架构、功能和应用领域上有许多区别。下面我会详细对比这两者的各个方面，帮助你更好地理解它们的特点。

---

## **1. 基本架构**

| **对比项**   | **STM32**                   | **80C51 (8051)**                    |
| --------- | --------------------------- | ----------------------------------- |
| **架构类型**  | ARM Cortex-M 系列（32位 RISC架构） | 8位 CISC 架构（Intel 8051架构）            |
| **CPU位宽** | 32位                         | 8位                                  |
| **指令集**   | 精简指令集（RISC）                 | 复杂指令集（CISC）                         |
| **处理器主频** | 高达 400MHz（例如 STM32H7 系列）    | 最高 40MHz（80C51 系列一般为 12MHz ~ 40MHz） |
| **处理能力**  | 高性能（多核、硬浮点单元等）              | 低性能，适合低复杂度任务                        |

**总结**：

- **STM32** 采用 ARM Cortex-M 系列 32位处理器，具有现代 RISC 架构，能高效执行大量的任务，并且支持更高的主频。
- **80C51** 是 8位 CISC 架构，主频相对较低，适合于处理简单的控制任务。

---

## **2. 性能对比**

| **对比项**   | **STM32**                     | **80C51 (8051)**                     |
| --------- | ----------------------------- | ------------------------------------ |
| **处理器性能** | 高性能，支持更复杂的计算和实时任务处理           | 性能较低，适合低速、低功耗的简单任务                   |
| **运算能力**  | 强大的运算能力，支持浮点运算，向量运算等          | 只能执行简单的整数运算，不能直接处理浮点运算               |
| **内存**    | 通常有大容量的 Flash 和 RAM，支持 DMA、缓存 | 内存较小，典型为 4KB Flash 和 128B ~ 256B RAM |
| **I/O速度** | 高速、高带宽的外设接口                   | 较低的 I/O 速度，适合简单外设的连接                 |

**总结**：

- **STM32** 具有强大的运算能力和更高的性能，适用于需要快速处理的应用，如音视频处理、复杂控制算法。
- **80C51** 适用于较为简单的应用，如基础的传感器控制、简单的自动化系统等。

---

## **3. 外设支持**

| **对比项**     | **STM32**                       | **80C51 (8051)**                |
| ----------- | ------------------------------- | ------------------------------- |
| **定时器**     | 多个高级定时器，支持 PWM、捕获、比较功能          | 基本定时器，功能简单                      |
| **通讯接口**    | 支持多种接口（USART、SPI、I2C、CAN、USB等）  | 基本的 UART，有限的外设支持                |
| **ADC/DAC** | 高精度的多通道 ADC/DAC                 | 无内置 ADC/DAC，通常需要外部模块            |
| **存储器**     | 大容量 Flash 和 SRAM，部分具有外部存储接口     | 4KB Flash，128B ~ 256B SRAM，存储较小 |
| **扩展功能**    | 可支持 USB、Ethernet、CAN、SDIO、LCD 等 | 基本没有复杂扩展功能，仅有简单的并行 I/O          |

**总结**：

- **STM32** 提供多种强大而复杂的外设接口（如高精度 ADC、DAC、USB、以太网等），支持更为复杂的系统设计。
- **80C51** 的外设支持较为基础，适合简单的控制和通信任务。

---

## **4. 开发工具与生态**

|**对比项**|**STM32**|**80C51 (8051)**|
|---|---|---|
|**开发环境**|支持多个开发平台（如 STM32CubeIDE、Keil、IAR等）|传统开发环境，如 Keil、ASM、C 编译器|
|**调试工具**|高级调试功能，支持 JTAG、SWD、仿真|基本调试工具，支持简单的串口调试|
|**开发难度**|较高，尤其是复杂的外设配置和性能调优|相对简单，开发周期较短，入门容易|
|**库支持**|STM32Cube 库提供广泛的驱动和中间件支持|库支持较少，需要更多手动配置|

**总结**：

- **STM32** 拥有现代化的开发工具和庞大的生态系统，开发效率较高，但对新手来说可能需要一定学习曲线。
- **80C51** 开发简单，适合小规模或低功耗系统，且开发工具相对成熟，但功能和性能有限。

---

## **5. 功耗与应用领域**

|**对比项**|**STM32**|**80C51 (8051)**|
|---|---|---|
|**功耗**|提供多种低功耗模式，适合 IoT 设备、便携设备|功耗较低，适合简单控制任务|
|**应用领域**|适合高性能嵌入式应用，如智能家居、工业控制、物联网、汽车电子等|适用于低端嵌入式设备，如家电控制、简单传感器控制、仪表等|

**总结**：

- **STM32** 提供丰富的低功耗模式，适合智能家居、医疗设备、汽车等对功耗有一定要求的高性能应用。
- **80C51** 适合简单的控制任务，功耗较低，但不适合复杂任务。

---

## **6. 成本**

|**对比项**|**STM32**|**80C51 (8051)**|
|---|---|---|
|**单价**|中高，取决于具体型号，通常在 $1 ~ $10 之间|低，通常在 $0.5 ~ $3 之间|
|**性价比**|对于高性能应用性价比高|对于简单应用性价比高|

**总结**：

- **80C51** 的单价通常较低，适合成本敏感且需求简单的应用。
- **STM32** 适合对性能要求较高的应用，虽然价格略高，但提供的功能和性能远超 80C51。

---

## **总结对比**

|**特点**|**STM32**|**80C51**|
|---|---|---|
|**处理能力**|高（32位，RISC，支持浮点、向量等）|低（8位，CISC）|
|**性能**|强（高频、强运算能力）|弱（较低频、运算能力有限）|
|**外设支持**|丰富（多种外设接口、高精度 ADC/DAC）|基本（有限的外设接口）|
|**开发工具**|现代（CubeMX，IDE，调试工具完善）|传统（ASM、Keil 等）|
|**功耗**|低功耗（适用于 IoT、便携设备）|非常低（适用于小型设备）|
|**应用领域**|高性能、复杂应用（智能家居、工业控制等）|简单控制任务（家电、仪表等）|
|**价格**|中高，适合高性能应用|低，适合低成本应用|

---

### **何时选择 STM32？**

- 需要高性能、复杂任务，如智能家居、机器人、物联网设备、高速数据处理等。
- 需要丰富的外设支持，如 USB、CAN、Ethernet、精确的 ADC/DAC 等。

### **何时选择 80C51？**

- 需要低成本、简单控制任务的应用，如家电、简单的传感器或仪器控制。
- 对功耗和成本有严格要求，但功能需求较简单。

如果你的项目对性能和外设支持有较高需求，选择 **STM32** 会更合适；如果你只是做一个简单的嵌入式控制系统，**80C51** 可能会是一个更便宜的选择。

---

stm32如果没有While 1 会退出吗？
在 STM32 或其他嵌入式系统中，**`main()` 函数执行完毕后**的行为通常取决于程序的结构以及使用的开发环境。对于 STM32，标准行为是程序 **不会自动重头再执行**，而是会进入一种 **不可预测的状态**，或者会进入一个 **死循环**，以防止系统“退出”。一般来说，嵌入式系统的程序设计是要求不停运行的，因此主函数中的逻辑通常会让程序保持在某种循环状态，或至少保持系统在某种稳定的状态。

### **1. 标准行为：进入死循环**

在 STM32 和类似的嵌入式系统中，**`main()` 函数执行完后**，通常会进入一个 **死循环**，以防止 CPU 空闲后进入不确定状态。这是因为嵌入式系统通常不应该像普通应用程序那样退出，而是应该保持工作或等待事件（如中断、定时器、外设状态变化等）。

例如，通常的 STM32 代码结构如下：

```c
int main(void) {
    // 系统初始化
    SystemInit();
    HAL_Init();

    // 初始化外设和任务
    // 例如初始化GPIO、UART、定时器等

    // 主循环
    while (1) {
        // 执行主任务，比如外设控制、数据处理等
        // HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_0);  // 示例任务
    }
}
```

在上面的代码中，`main()` 函数结束时并不会退出，而是通过 `while (1)` 循环保持系统持续运行。如果没有 `while (1)`，程序就会进入死循环或者执行到程序的结束位置。

### **2. 程序结束后**会进入不可预测状态

如果在 `main()` 函数末尾没有明确的循环或者处理逻辑，程序就会执行完 `main()` 函数的代码，然后进入 **程序结束后的不可预测状态**。这意味着在 `main()` 函数执行完毕后，**CPU 会继续执行空闲的内存地址，导致程序崩溃**，这通常是不希望发生的。

为避免这种情况，很多 STM32 的库和初始化代码会将 `main()` 函数结束后引导到一个死循环，防止程序直接“退出”或崩溃。死循环代码通常如下：

```c
while (1) {
    // 程序结束后会停在这里，保持系统运行
    // 也可以执行低功耗操作，如待机模式
}
```

这样，程序就不会执行到未知的内存地址，确保系统保持在一个稳定的状态。

### **3. 中断和低功耗模式的影响**

在 STM32 中，**`main()` 函数可以依赖中断机制**来保持程序运行，即使 `main()` 函数没有一个显式的 `while(1)` 循环。例如，MCU 可以进入低功耗模式（如 SLEEP 模式）并等待中断触发。

例如：

```c
int main(void) {
    // 初始化系统
    SystemInit();
    HAL_Init();

    // 初始化外设，如定时器、外部中断等
    HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_0);  // 示例中断

    // 进入低功耗模式，等待中断触发
    while (1) {
        __WFI();  // 进入低功耗模式，直到中断唤醒
    }
}
```

在这里，`while(1)` 并不是用来执行任务的，而是为了使 MCU 进入低功耗模式，等待中断事件发生。

### **4. 可能的行为总结**

- **如果 `main()` 函数执行完毕，且没有 `while(1)`**：
    
    - 程序会进入一个死循环，或者会 **退出并进入不可预测的状态**。
    - 程序的控制流会变得不确定，可能导致系统崩溃。
    - **大多数情况下，程序会设计成在 `main()` 函数中保持运行**，例如通过一个永远不会退出的循环或通过中断处理。
- **如果使用了外部中断**，程序会被设计成响应中断，甚至没有显式的 `while(1)` 循环。此时，程序会等待中断事件触发，并进入低功耗模式等。
    

### **5. 总结**

STM32 的程序设计通常会保证程序持续运行。即使没有 `while(1)` 循环，`main()` 函数执行完后也会通过一些机制（如死循环、低功耗模式等）保持系统稳定。如果程序需要在主循环外部运行某些任务，通常会依赖中断或事件驱动的方式，而不是让程序“退出”。

蟑螂最低温度
## HAL 库 vs LL库？
[HAL库](https://so.csdn.net/so/search?q=HAL%E5%BA%93&spm=1001.2101.3001.7020)和LL库都是STM32的底层驱动库，用于对微控制器的外设进行配置和控制。它们的主要区别在于设计理念和使用方式。

1. 设计理念：  
   - HAL库（Hardware Abstraction Layer）：HAL库是一个高级抽象层，提供了更友好和易于使用的API。它将底层的寄存器操作和配置封装在函数中，使得用户可以更方便地使用外设功能。HAL库适合于快速开发和简单应用。  
   - LL库（Low-Level）：LL库是一个低级别的库，更接近硬件寄存器的操作。它提供了直接操作寄存器的函数，使得用户可以更精确地配置和控制外设。LL库适合于对外设进行深入了解和高度优化的应用。

2. 功能支持：  
   - HAL库：HAL库提供了丰富的函数和宏定义，涵盖了大多数常用的外设功能。它提供了各种功能模块的初始化、配置和控制函数，包括GPIO、UART、SPI、I2C等外设。此外，HAL库还提供了一些高级功能，如中断处理和DMA传输。  
   - LL库：LL库提供了与外设的底层寄存器直接操作相关的函数。它没有封装高级功能，用户需要手动配置和操作寄存器来实现所需的功能。LL库在灵活性和性能方面更有优势，但使用起来也更复杂。

3. 使用方式：  
   - HAL库：HAL库使用起来相对简单，用户只需要调用相应的函数进行初始化和控制即可。HAL库提供了一种事件驱动的编程模型，用户可以通过回调函数来处理中断和DMA传输等事件。  
   - LL库：LL库的使用方式更接近裸机编程，用户需要手动编写寄存器的配置和操作代码。这需要对外设的寄存器结构和功能有较深的了解。

综上所述，HAL库适用于快速开发和简单应用，而LL库适用于对外设进行深入了解和高度优化的应用


TIM1定时器？
看数据手册
2025/2/9日完结第一季


`static int a = 0;` 定义在 `a.h` 头文件中，意味着 **每个包含 `a.h` 的 .c/.cpp 文件** 都会拥有一个独立的 `a` 变量（**静态变量具有内部链接性**）。

如果多个 `.c` 文件 `#include "a.h"`，每个 `.c` 文件都会各自生成一个 `static int a = 0;`，但不会引发 **链接错误**，因为 `static` 变量的作用域限制在编译单元（**单个 .c 文件**）。

**但可能会导致编译错误**，如果 `a.h` 被多次 `#include`，并且 `a` 的定义发生冲突（如 `extern` 相关声明不匹配）。

---

### **示例 1：不会报错的情况**

```c
// a.h
#ifndef A_H
#define A_H

static int a = 0;  // 每个包含 a.h 的 .c 文件都有一个独立的 a 变量

#endif
```

```c
// b.h
#ifndef B_H
#define B_H

#include "a.h"  // 引入 a.h，不会报错，但每个 .c 文件都有自己的 a 变量

#endif
```

```c
// main.c
#include <stdio.h>
#include "b.h"

int main() {
    printf("%d\n", a); // a 是 main.c 内部的静态变量
    return 0;
}
```

✅ **不会报错**，但 `a` 仅限 `main.c` 使用。

---

### **示例 2：多个 C 文件包含 `a.h`**

```c
// file1.c
#include "a.h"
void func1() {
    a += 1;  // file1.c 内部的 a 变量
}
```

```c
// file2.c
#include "a.h"
void func2() {
    a += 2;  // file2.c 内部的 a 变量，与 file1.c 的 a 不是同一个变量
}
```

✅ **不会报链接错误**，但 `file1.c` 和 `file2.c` 中的 `a` 变量是 **独立的**，相互不可见。

---

### **示例 3：如果在 `b.h` 里使用 `extern`**

```c
// a.h
#ifndef A_H
#define A_H

static int a = 0;

#endif
```

```c
// b.h
#ifndef B_H
#define B_H

#include "a.h"
extern int a;  // ❌ a 是 static 变量，不允许 extern 引用，会报错！

#endif
```

✅ **会报错**，因为 `static int a` 仅限 `a.h` 所在的编译单元，不能 `extern` 访问。

---

### **正确的写法**

如果 `a` 需要被多个文件共享，应当：

1. 在 `a.h` 里声明 `extern int a;`
2. 在 `a.c` 里定义 `int a = 0;`

```c
// a.h
#ifndef A_H
#define A_H

extern int a;  // 仅声明，不定义

#endif
```

```c
// a.c
#include "a.h"
int a = 0;  // 变量的定义
```

```c
// file1.c
#include "a.h"
void func1() {
    a += 1;  // 访问全局 a
}
```

✅ 这样 `a` 就是一个 **全局变量**，可以被 `file1.c` 和 `file2.c` 共享。

---

### **结论**

1. `static int a = 0;` 放在头文件，**每个包含该头文件的 C 文件都会有自己的 `a` 变量**，不会报链接错误。
2. 不能 `extern int a;` 引用 `static` 变量，否则 **编译错误**。
3. 如果 `a` 需要在多个 C 文件共享，**用 `extern` 声明 + .c 文件定义**。

🔹 **如果 `a` 只是某个 C 文件内部使用，放 `static` 是安全的**。  
🔹 **如果 `a` 需要多个文件共享，不要 `static`，改用 `extern`**。


